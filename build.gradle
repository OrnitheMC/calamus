import com.google.common.hash.Hashing
import com.google.common.io.Files
import cuchaz.enigma.command.ConvertMappingsCommand
import groovy.json.JsonSlurper
import groovy.xml.XmlSlurper
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.stitch.util.CalamusUtil
import net.ornithemc.mappingutils.MappingUtils
import net.ornithemc.nester.Nester
import org.apache.commons.io.FileUtils

import java.nio.charset.Charset
import java.nio.file.Paths

buildscript {
    repositories {
        maven {
            name "Quilt"
            url "https://maven.quiltmc.org/repository/release"
        }
        maven {
            name "Ornithe"
            url "https://maven.ornithemc.net/releases"
        }
    }

    dependencies {
        classpath "net.ornithemc:enigma-cli:1.2.7"
        classpath "net.ornithemc:nester:1.0.0"
        classpath "net.ornithemc:stitch:0.9.1"
        classpath "net.ornithemc:mapping-utils:0.7.0"
        classpath "commons-io:commons-io:2.8.0"
        classpath "org.codehaus.groovy:groovy-json:3.0.9"
        classpath "org.codehaus.groovy:groovy-xml:3.0.9"
    }
}

plugins {
    id 'de.undercouch.download' version '4.1.1'
    id 'java'
    id 'maven-publish'
}

def ENV = System.getenv()

def jarSetupGroup = "jar setup"
def mappingGenerationGroup = "mapping generation"
def cacheFilesMinecraft = file(".gradle/minecraft")
def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")

def version_id = ENV.MC_VERSION
def environment = parseEnvironment(version_id)
def minecraft_version = parseVersion(version_id, environment)

def from_version_id = ENV.FROM_MC_VERSION
def from_environment = parseEnvironment(from_version_id)
def from_minecraft_version = parseVersion(from_version_id, from_environment)

def versionDetails = null
def versionDetailsFile = new File(cacheFilesMinecraft, "${minecraft_version}-details.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")
def mergedJar = new File(cacheFilesMinecraft, "${minecraft_version}-merged.jar")
def mainJar = null
def calamusFile = file("mappings/${version_id}.tiny")

def fromClientJar = new File(cacheFilesMinecraft, "${from_minecraft_version}-client.jar")
def fromServerJar = new File(cacheFilesMinecraft, "${from_minecraft_version}-server.jar")
def fromMergedJar = new File(cacheFilesMinecraft, "${from_minecraft_version}-merged.jar")
def fromMainJar = null
def fromCalamusFile = file("mappings/${from_version_id}.tiny")

def defaultPackage = "net/minecraft/unmapped/"
def namespace = "intermediary"
def nameLength = 7

def maven_group = "calamus-${namespace}"

enum Environment {

    MERGED, CLIENT, SERVER

    public boolean isMerged() {
        return this == MERGED
    }

    public boolean isClient() {
        return this == MERGED || this == CLIENT
    }

    public boolean isServer() {
        return this == MERGED || this == SERVER
    }
}

static Environment parseEnvironment(String id) {
    if (id == null) {
        return null
    }
    if (id.endsWith("-client")) {
        return Environment.CLIENT
    }
    if (id.endsWith("-server")) {
        return Environment.SERVER
    }

    return Environment.MERGED
}

static String parseVersion(String id, Environment environment) {
    switch (environment) {
    case Environment.CLIENT:
        return id.substring(0, id.length() - "-client".length())
    case Environment.SERVER:
        return id.substring(0, id.length() - "-server".length())
    case Environment.MERGED:
        return id
    default:
        return null
    }
}

static boolean validateChecksum(File file, String checksum) {
    if (file != null) {
        //noinspection GrDeprecatedAPIUsage
        def hash = Files.asByteSource(file).hash(Hashing.sha1())
        def builder = new StringBuilder()
        hash.asBytes().each {
            builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
        }
        return builder.toString() == checksum
    }
    return false
}

task downloadVersionsManifest {
    group = jarSetupGroup
    //inputs.property "mc_ver", minecraft_version
    inputs.property "currenttime", new Date()

    outputs.file(manifestFile)

    doLast {
        logger.lifecycle(":downloading minecraft versions manifest")
        FileUtils.copyURLToFile(new URL("https://skyrising.github.io/mc-versions/version_manifest.json"), manifestFile)
    }
}

static def getManifestVersion(File manifestFile, String minecraft_version) {
    def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile, Charset.defaultCharset())) : null
    return manifest != null ? manifest.versions.stream().filter({
        (it.id == minecraft_version)
    }).findFirst() : java.util.Optional.empty()
}

task downloadVersionDetails(dependsOn: downloadVersionsManifest) {
    group = jarSetupGroup
    def manifestVersion = getManifestVersion(manifestFile, minecraft_version)
    inputs.property "manifestUrl", manifestVersion.isPresent() ? manifestVersion.get().url : -1

    outputs.file versionDetailsFile
    outputs.upToDateWhen {
        return false
    }

    doLast {
        if (manifestVersion.isPresent() || versionDetailsFile.exists()) {
            if (manifestVersion.isPresent()) {
                FileUtils.copyURLToFile(new URL(manifestVersion.get().details), versionDetailsFile)
            }
        } else {
            throw new RuntimeException("No version details for Minecraft version ${minecraft_version} (Did you forget to set the (FROM_)MC_VERSION environment variable?)")
        }

        versionDetails = new JsonSlurper().parseText(FileUtils.readFileToString(versionDetailsFile, Charset.defaultCharset()))

        if (versionDetails.sharedMappings) {
            if (!environment.isMerged()) {
                throw new RuntimeException("Minecraft version ${minecraft_version} is only available as merged but was requested for ${environment}!")
            }
        } else {
            if (environment.isMerged()) {
                throw new RuntimeException("Minecraft version ${minecraft_version} cannot be merged - please select either the client or server environment!")
            }
            if (environment.isClient() && !versionDetails.client) {
                throw new RuntimeException("Minecraft version ${minecraft_version} does not have a client jar!")
            }
            if (environment.isServer() && !versionDetails.server) {
                throw new RuntimeException("Minecraft version ${minecraft_version} does not have a server jar!")
            }
        }

        switch (environment) {
        case Environment.CLIENT:
            mainJar = clientJar
            fromMainJar = fromClientJar
            break
        case Environment.SERVER:
            mainJar = serverJar
            fromMainJar = fromServerJar
            break
        case Environment.MERGED:
            mainJar = mergedJar
            fromMainJar = fromMergedJar
            break
        }
    }
}

task downloadMcJars(dependsOn: downloadVersionDetails) {
    group = jarSetupGroup
    inputs.files versionDetailsFile

    outputs.files(clientJar, serverJar)
    outputs.upToDateWhen {
        if (project.gradle.startParameter.isRefreshDependencies()) {
            return false
        }
        def validClient = (!environment.isClient() || (clientJar.exists() && validateChecksum(clientJar, versionDetails.downloads.client.sha1)))
        def validServer = (!environment.isServer() || (serverJar.exists() && validateChecksum(serverJar, versionDetails.downloads.server.sha1)))

        return validClient && validServer
    }

    doLast {
        if (!versionDetailsFile.exists() || versionDetails == null) {
            throw new RuntimeException("Can't download the jars without the ${versionDetailsFile.name} file!")
        }

        logger.lifecycle(":downloading minecraft jar(s) for ${version_id}")

        if (environment.isClient()) {
            download {
                src new URL(versionDetails.downloads.client.url)
                dest clientJar
                overwrite false
            }
        }
        if (environment.isServer()) {
            download {
                src new URL(versionDetails.downloads.server.url)
                dest serverJar
                overwrite false
            }
        }
    }
}

task mergeJars(dependsOn: downloadMcJars) {
    group = jarSetupGroup
    inputs.files downloadMcJars.outputs.files.files

    outputs.file(mergedJar)
    outputs.upToDateWhen {
        return false
    }

    doLast {
        if (environment.isMerged()) {
            logger.lifecycle(":merging jars")
            def jarMerger = new JarMerger(clientJar, serverJar, mergedJar)
            jarMerger.merge()
            jarMerger.close()
        } else {
            logger.lifecycle(":skipping - ${version_id} is not merged")
        }
    }
}

task generateCalamus(dependsOn: [downloadVersionDetails, mergeJars]) {
    group = mappingGenerationGroup

    outputs.file(calamusFile)
    outputs.upToDateWhen {
        return false
    }

    doLast {
        if (calamusFile.exists()) {
            return
        }

        List<String> args = new ArrayList<>()
        args.add("--default-package")
        args.add(defaultPackage)
        args.add("--target-namespace")
        args.add(namespace)
        args.add("--name-length")
        args.add(Integer.toString(nameLength))
        if (environment.isClient()) {
            args.add("--client-hash")
            args.add(versionDetails.downloads.client.sha1)
        }
        if (environment.isServer()) {
            args.add("--server-hash")
            args.add(versionDetails.downloads.server.sha1)
        }

        CalamusUtil.generateCalamus(mainJar, calamusFile, args.toArray(new String[args.size()]))
    }
}

static File findMatches(Environment fromEnv, String from, Environment toEnv, String to) {
    // some of the matches use version names
    // that do not match the version ids
    def versionTranslations = new HashMap<String, String>() {
        {
            put("b1.8-pre1-2"   , "b1.8-pre1-201109091357")
            put("b1.9-pre3-2"   , "b1.9-pre3-201110061402")
            put("b1.9-pre4-1435", "b1.9-pre4-201110131434")
            put("1.3"           , "1.3-pre-07261249")
            put("1.4"           , "1.4-pre")
            put("1.4.1"         , "1.4.1-pre-10231538")
            put("1.4.3"         , "1.4.3-pre")
            put("13w16a"        , "13w16a-04192037")
            put("13w16b"        , "13w16b-04232151")
            put("13w23b"        , "13w23b-06080101")
            put("1.6"           , "1.6-pre-06251516")
            put("1.6.2"         , "1.6.2-091847")
            put("1.6.3"         , "1.6.3-pre-171231")
            put("13w36a"        , "13w36a-09051446")
            put("13w36b"        , "13w36b-09061310")
            put("13w41b"        , "13w41b-1523")
            put("1.7"           , "1.7-pre")
            put("1.7.1"         , "1.7.1-pre")
            put("1.7.3"         , "1.7.3-pre")
            put("1.7.7"         , "1.7.7-101331")
            put("14w04b"        , "14w04b-1554")
            put("14w27b"        , "14w27b-07021646")
            put("14w34c"        , "14w34c-08191549")
            put("16w50a"        , "16w50a-1438")
            put("2point0_red"   , "af-2013-red")
            put("2point0_blue"  , "af-2013-blue")
            put("2point0_purple", "af-2013-purple")
            put("15w14a"        , "af-2015")
            put("1.RV-Pre1"     , "af-2016")
        }
    }

    from = versionTranslations.getOrDefault(from, from);
    to = versionTranslations.getOrDefault(to, to);

    return findMatches(fromEnv, from, toEnv, to, false);
}

static File findMatches(Environment fromEnv, String from, Environment toEnv, String to, boolean orThrow) {
    File matches = findMatches(new File("matches/matches"), fromEnv, from, toEnv, to);

    if (matches != null) {
        return matches;
    }

    // no matches found...
    if (orThrow) {
        throw new RuntimeException("matches from ${fromEnv.name().toLowerCase()} ${from} to ${toEnv.name().toLowerCase()} ${to} do not exist!");
    } else {
        File invertedMatches = findMatches(toEnv, to, fromEnv, from, true);
        matches = new File(invertedMatches.parentFile, "temp.match")

        MappingUtils.invertMatches(invertedMatches.toPath(), matches.toPath());
    }

    return matches;
}

static File findMatches(File dir, Environment fromEnv, String from, Environment toEnv, String to) {
    String name

    if (fromEnv == toEnv) {
        name = "${from}#${to}.match"
    } else {
        name = "${fromEnv.name().toLowerCase()}-${from}#${toEnv.name().toLowerCase()}-${to}.match"
    }

    return findMatches(dir, name)
}

static File findMatches(File dir, String name) {
    if (dir.isDirectory()) {
        File matches = new File(dir, name);
 
        if (matches.exists()) {
            return matches;
        }

        for (File f : dir.listFiles()) {
            matches = findMatches(f, name);

            if (matches != null) {
                return matches;
            }
        }
    }

    return null;
}

task updateCalamus(dependsOn: [downloadVersionDetails, mergeJars]) {
    group = mappingGenerationGroup
    inputs.files(fromMainJar, mainJar)

    outputs.file(calamusFile)
    outputs.upToDateWhen {
        return false
    }

    doLast {
        if (calamusFile.exists()) {
            return
        }

        if (!fromCalamusFile.exists()) {
            throw new RuntimeException("Cannot update calamus from ${from_version_id} to ${version_id}: calamus for ${from_version_id} does not exist!")
        }

        List<File> oldJars = new ArrayList<>()
        List<File> oldCalamusFiles = new ArrayList<>()
        List<File> matchesFiles = new ArrayList<>()
        List<String> args = new ArrayList<>()

        oldJars.add(fromMainJar)
        oldCalamusFiles.add(fromCalamusFile)
        matchesFiles.add(findMatches(from_environment, from_minecraft_version, environment, minecraft_version))
        args.add("--default-package")
        args.add(defaultPackage)
        args.add("--target-namespace")
        args.add(namespace)
        args.add("--name-length")
        args.add(Integer.toString(nameLength))
        if (environment.isClient()) {
            args.add("--client-hash")
            args.add(versionDetails.downloads.client.sha1)
        }
        if (environment.isServer()) {
            args.add("--server-hash")
            args.add(versionDetails.downloads.server.sha1)
        }

        CalamusUtil.updateCalamus(oldJars, mainJar, oldCalamusFiles, calamusFile, matchesFiles, args.toArray(new String[args.size()]))
    }
}

static List<String> getPublishedVersions(def maven_group) {
    def xml = new URL("https://maven.ornithemc.net/releases/net/ornithemc/${maven_group}/maven-metadata.xml").text
    def metadata = new XmlSlurper().parseText(xml)
    def versions = metadata.versioning.versions.version*.text()
    return versions
}

def publishedVersions
try {
    publishedVersions = getPublishedVersions(maven_group)
} catch (ignored) {
}

def localMappingsPath = "$buildDir/v2Mappings"
new File(localMappingsPath).mkdirs()
file('mappings').eachFile {
    if (!it.name.endsWith(".tiny")) return

    def mcVer = it.name.replace(".tiny", "")

    if (publishedVersions != null && publishedVersions.contains(mcVer)) {
        return
    }

    File v1MappingFile = it
    File v2MappingFile = new File("$localMappingsPath/${it.name}")
    File nests = file("nests/${mcVer}.nest")

    def conversionTask = "convert${it.name}ToV2"
    tasks.register(conversionTask) {
        group = "V2 Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v2MappingFile)

        doLast {
            new ConvertMappingsCommand().run(
                    "tiny",
                    v1MappingFile.path,
                    "tinyv2:official:${namespace}",
                    v2MappingFile.path
            )
        }
    }

    Jar makeV1Jar = makeJar(mcVer, v1MappingFile, nests, false)
    Jar makeV2Jar = makeJar(mcVer, v2MappingFile, nests, true)

    build.dependsOn makeV1Jar
    build.dependsOn makeV2Jar

    makeV2Jar.dependsOn conversionTask

    publishing {
        publications {
            create("${mcVer.replace(" ", "")}_mavenJava", MavenPublication) {
                groupId 'net.ornithemc'
                artifactId maven_group
                version mcVer
                artifact(makeV1Jar.archiveFile) {
                    builtBy makeV1Jar
                }
                artifact(makeV2Jar.archiveFile) {
                    builtBy makeV2Jar
                    classifier = "v2"
                }
            }
        }
    }

}

def makeJar(String mcVersion, File mappings, File nests, boolean v2) {
    def jarFilename = "calamus-" + mcVersion + (v2 ? "-v2" : "")
    return task("${mcVersion}_makeJar" + (v2 ? "v2" : ""), type: Jar) {
        baseName jarFilename
        from(file(mappings)) {
            into "mappings"
            rename mappings.name, "mappings.tiny"
        }
        if (nests.exists()) {
            from(file(nests)) {
                into "mappings"
                rename nests.name, "mappings.nest"
            }
        }
        destinationDirectory = file("build/jars")
    }
}

publishing {
    repositories {
        if (ENV.MAVEN_URL) {
            maven {
                url ENV.MAVEN_URL
                credentials {
                    username ENV.MAVEN_USERNAME
                    password ENV.MAVEN_PASSWORD
                }
                authentication {
                    basic(BasicAuthentication)
                }
            }
        }
    }
}
