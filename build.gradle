import com.google.common.hash.Hashing
import com.google.common.io.Files
import cuchaz.enigma.command.ConvertMappingsCommand
import groovy.json.JsonSlurper
import groovy.xml.XmlSlurper
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.stitch.util.CalamusUtil
import net.ornithemc.mappingutils.MappingUtils
import net.ornithemc.nester.Nester
import org.apache.commons.io.FileUtils

import java.nio.charset.Charset
import java.nio.file.Paths

buildscript {
    repositories {
        maven {
            name "Quilt"
            url "https://maven.quiltmc.org/repository/release"
        }
        maven {
            name "Ornithe"
            url "https://maven.ornithemc.net/releases"
        }
    }

    dependencies {
        classpath "net.ornithemc:enigma-cli:1.2.7"
        classpath "net.ornithemc:nester:1.0.0"
        classpath "net.ornithemc:stitch:0.7.13"
	classpath "net.ornithemc:mapping-utils:0.6.2"
        classpath "commons-io:commons-io:2.8.0"
        classpath "org.codehaus.groovy:groovy-json:3.0.9"
        classpath "org.codehaus.groovy:groovy-xml:3.0.9"
    }
}

plugins {
    id 'de.undercouch.download' version '4.1.1'
    id 'java'
    id 'maven-publish'
}

def ENV = System.getenv()

def jarSetupGroup = "jar setup"
def mappingGenerationGroup = "mapping generation"
def cacheFilesMinecraft = file(".gradle/minecraft")
def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")

def version_id = ENV.MC_VERSION
def environment = parseEnvironment(version_id)
def minecraft_version = parseVersion(version_id, environment)

def old_version_id = ENV.OLD_MC_VERSION
def old_environment = parseEnvironment(old_version_id)
def old_minecraft_version = parseVersion(old_version_id, old_environment)

// files for the version for which to generate calamus
def versionDetails = null
def versionDetailsFile = new File(cacheFilesMinecraft, "${minecraft_version}-details.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")
def mergedJar = new File(cacheFilesMinecraft, "${minecraft_version}-merged.jar")
def mainJar = null
def nestedJar = new File(cacheFilesMinecraft, "${version_id}-nested.jar")
def nestsFile = file("nests/${version_id}.nest")
def calamusFile = file("mappings/${version_id}.tiny")

// files for the version from which to update calamus
def oldVersionDetails = null
def oldVersionDetailsFile = new File(cacheFilesMinecraft, "${old_minecraft_version}-details.json")
def oldClientJar = new File(cacheFilesMinecraft, "${old_minecraft_version}-client.jar")
def oldServerJar = new File(cacheFilesMinecraft, "${old_minecraft_version}-server.jar")
def oldMergedJar = new File(cacheFilesMinecraft, "${old_minecraft_version}-merged.jar")
def oldMainJar = null
def oldNestedJar = new File(cacheFilesMinecraft, "${old_version_id}-nested.jar")
def oldNestsFile = file("nests/${old_version_id}.nest")
def oldCalamusFile = file("mappings/${old_version_id}.tiny")

enum Environment {

    MERGED, CLIENT, SERVER

    public boolean isMerged() {
        return this == MERGED
    }

    public boolean isClient() {
        return this == MERGED || this == CLIENT
    }

    public boolean isServer() {
        return this == MERGED || this == SERVER
    }
}

static Environment parseEnvironment(String id) {
    def client = "-client"
    def server = "-server"

    if (id.endsWith(client)) {
        return Environment.CLIENT
    }
    if (id.endsWith(server)) {
        return Environment.SERVER
    }

    return Environment.MERGED
}

static String parseVersion(String id, Environment environment) {
    switch (environment) {
    case Environment.CLIENT:
        return id.substring(0, id.length() - "-client".length())
    case Environment.SERVER:
        return id.substring(0, id.length() - "-server".length())
    case Environment.MERGED:
        return id
    }
}

static boolean validateChecksum(File file, String checksum) {
    if (file != null) {
        //noinspection GrDeprecatedAPIUsage
        def hash = Files.asByteSource(file).hash(Hashing.sha1())
        def builder = new StringBuilder()
        hash.asBytes().each {
            builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
        }
        return builder.toString() == checksum
    }
    return false
}

task downloadVersionsManifest {
    group = jarSetupGroup
    //inputs.property "mc_ver", minecraft_version
    inputs.property "currenttime", new Date()

    outputs.file(manifestFile)

    doLast {
        logger.lifecycle(":downloading minecraft versions manifest")
        FileUtils.copyURLToFile(new URL("https://skyrising.github.io/mc-versions/version_manifest.json"), manifestFile)
    }
}

static def getManifestVersion(File manifestFile, String minecraft_version) {
    def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile, Charset.defaultCharset())) : null
    return manifest != null ? manifest.versions.stream().filter({
        (it.id == minecraft_version)
    }).findFirst() : java.util.Optional.empty()
}

task downloadVersionDetails(dependsOn: downloadVersionsManifest) {
    group = jarSetupGroup
    def manifestVersion = getManifestVersion(manifestFile, minecraft_version)
    inputs.property "manifestUrl", manifestVersion.isPresent() ? manifestVersion.get().url : -1

    outputs.file versionDetailsFile

    doLast {
        versionDetails = getVersionDetails(version_id, environment, minecraft_version, manifestFile, versionDetailsFile)
        mainJar = getMainJar(environment, clientJar, serverJar, mergedJar)
    }
}

task downloadOldVersionDetails(dependsOn: downloadVersionsManifest) {
    group = jarSetupGroup
    def manifestVersion = getManifestVersion(manifestFile, old_minecraft_version)
    inputs.property "manifestUrl", manifestVersion.isPresent() ? manifestVersion.get().url : -1

    outputs.file oldVersionDetailsFile

    doLast {
        oldVersionDetails = getVersionDetails(old_version_id, old_environment, old_minecraft_version, manifestFile, oldVersionDetailsFile)
        oldMainJar = getMainJar(old_environment, oldClientJar, oldServerJar, oldMergedJar)
    }
}

static def getVersionDetails(String version_id, Environment environment, String minecraft_version, File manifestFile, File versionDetailsFile) {
    def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

    if (manifestVersion.isPresent() || versionDetailsFile.exists()) {
        if (manifestVersion.isPresent()) {
            FileUtils.copyURLToFile(new URL(manifestVersion.get().details), versionDetailsFile)
        }
    } else {
        throw new RuntimeException("No version details for Minecraft version ${minecraft_version} (Did you forget to set the (OLD_)MC_VERSION environment variable?)")
    }

    def versionDetails = new JsonSlurper().parseText(FileUtils.readFileToString(versionDetailsFile, Charset.defaultCharset()))

    if (versionDetails.sharedMappings) {
        if (!environment.isMerged()) {
            throw new RuntimeException("Minecraft version ${minecraft_version} is only available as merged but was requested for ${environment}!")
        }
    } else {
        if (environment.isMerged()) {
            throw new RuntimeException("Minecraft version ${minecraft_version} cannot be merged - please select either the client or server environment!")
        }
        if (environment.isClient() && !versionDetails.client) {
            throw new RuntimeException("Minecraft version ${minecraft_version} does not have a client jar!")
        }
        if (environment.isServer() && !versionDetails.server) {
            throw new RuntimeException("Minecraft version ${minecraft_version} does not have a server jar!")
        }
    }

    return versionDetails
}

static File getMainJar(Environment environment, File clientJar, File serverJar, File mergedJar) {
    switch (environment) {
    case Environment.CLIENT:
        return clientJar
    case Environment.SERVER:
        return serverJar
    case Environment.MERGED:
        return mergedJar
    }
}

task downloadMcJars(dependsOn: downloadVersionDetails) {
    group = jarSetupGroup
    inputs.files versionDetailsFile

    outputs.files(clientJar, serverJar)
    outputs.upToDateWhen {
        return validateMcJars(environment, versionDetails, clientJar, serverJar)
    }

    doLast {
        if (!versionDetailsFile.exists() || versionDetails == null) {
            throw new RuntimeException("Can't download the jars without the ${versionDetailsFile.name} file!")
        }

        logger.lifecycle(":downloading minecraft jar(s) for ${version_id}")

        if (environment.isClient()) {
            download {
                src new URL(versionDetails.downloads.client.url)
                dest clientJar
                overwrite false
            }
        }
        if (environment.isServer()) {
            download {
                src new URL(versionDetails.downloads.server.url)
                dest serverJar
                overwrite false
            }
        }
    }
}

task downloadOldMcJars(dependsOn: downloadOldVersionDetails) {
    group = jarSetupGroup
    inputs.files oldVersionDetailsFile

    outputs.files(oldClientJar, oldServerJar)
    outputs.upToDateWhen {
        return validateMcJars(old_environment, oldVersionDetails, oldClientJar, oldServerJar)
    }

    doLast {
        if (!oldVersionDetailsFile.exists() || oldVersionDetails == null) {
            throw new RuntimeException("Can't download the jars without the ${versionDetailsFile.name} file!")
        }

        logger.lifecycle(":downloading minecraft jar(s) for ${old_version_id}")

        if (old_environment.isClient()) {
            download {
                src new URL(oldersionDetails.downloads.client.url)
                dest oldClientJar
                overwrite false
            }
        }
        if (old_environment.isServer()) {
            download {
                src new URL(oldVersionDetails.downloads.server.url)
                dest oldServerJar
                overwrite false
            }
        }
    }
}

static boolean validateMcJars(Environment environment, def versionDetails, File clientJar, File serverJar) {
    def validClient = (!environment.isClient() || (clientJar.exists() && validateChecksum(clientJar, versionDetails.downloads.client.sha1)))
    def validServer = (!environment.isServer() || (serverJar.exists() && validateChecksum(serverJar, versionDetails.downloads.server.sha1)))

    return validClient && validServer
}

task mergeJars(dependsOn: downloadMcJars) {
    group = jarSetupGroup
    inputs.files downloadMcJars.outputs.files.files

    outputs.file(mergedJar)

    doLast {
        mergeJars(logger, version_id, environment, minecraft_version, clientJar, serverJar, mergedJar)
    }
}

task mergeOldJars(dependsOn: downloadOldMcJars) {
    group = jarSetupGroup
    inputs.files downloadOldMcJars.outputs.files.files

    outputs.file(oldMergedJar)

    doLast {
        mergeJars(logger, old_version_id, old_environment, old_minecraft_version, oldClientJar, oldServerJar, oldMergedJar)
    }
}

static def mergeJars(def logger, String version_id, Environment environment, String minecraft_version, File clientJar, File serverJar, File mergedJar) {
    if (environment.isMerged() && !mergedJar.exists()) {
        logger.lifecycle(":merging jars")
        def jarMerger = new JarMerger(clientJar, serverJar, mergedJar)
        jarMerger.merge()
        jarMerger.close()
    }
}

task nestJar(dependsOn: mergeJars) {
    group = jarSetupGroup
    inputs.file mergedJar

    outputs.file(nestedJar)

    doLast {
        nestJar(logger, version_id, environment, minecraft_version, mainJar, nestedJar, nestsFile)
    }
}

task nestOldJar(dependsOn: mergeOldJars) {
    group = jarSetupGroup
    inputs.file oldMergedJar

    outputs.file(oldNestedJar)

    doLast {
        nestJar(logger, old_version_id, old_environment, old_minecraft_version, oldMainJar, oldNestedJar, oldNestsFile)
    }
}

static def nestJar(def logger, String version_id, Environment environment, String minecraft_version, File jar, File nestedJar, File nestsFile) {
    if (!nestedJar.exists() && nestsFile.exists()) {
        logger.lifecycle(":nesting jar")
        Nester.nestJar(new Nester.Options().silent(true), Paths.get(jar.getAbsolutePath()), Paths.get(nestedJar.getAbsolutePath()), Paths.get(nestsFile.getAbsolutePath()))
    }
}

task generateCalamus(dependsOn: [downloadVersionDetails, nestJar]) {
    group = mappingGenerationGroup
    inputs.files(mainJar, nestedJar)

    outputs.file(calamusFile)
    outputs.upToDateWhen {
        return calamusFile.exists()
    }

    doLast {
        if (calamusFile.exists()) {
            return
        }

        File jar = nestedJar.exists() ? nestedJar : mainJar
        List<String> args = new ArrayList<>()
        if (environment.isClient()) {
            args.add("--client-hash")
            args.add(versionDetails.downloads.client.sha1)
        }
        if (environment.isServer()) {
            args.add("--server-hash")
            args.add(versionDetails.downloads.server.sha1)
        }

        CalamusUtil.generateCalamus(jar, calamusFile, args.toArray())
    }
}

static File findMatches(String from, String to) {
    return findMatches(from, to, false);
}

static File findMatches(String from, String to, boolean orThrow) {
    // first check if we have our own nested matches
    File matches = findMatches(new File("nested-matches"), from, to);

    if (matches != null) {
        return matches;
    }

    // check skyrising's matches
    matches = findMatches(new File("matches/matches"));

    if (matches != null) {
        return matches;
    }

    // no matches found...
    if (orThrow) {
        throw new RuntimeException("matches from ${from} to ${to} do not exist!");
    } else {
        File invertedMatches = findMatches(to, from, true);
        matches = new File(".gradle/temp/${from}#${to}.match");

        MappingUtils.invertMatches(invertedMatches, matches);
    }

    return matches;
}

static File findMatches(File dir, String from, String to) {
    if (dir.isDirectory()) {
        File matches = new File(dir, "${from}#${to}.match");

        if (matches.exists()) {
            return matches;
        }

        for (File f : dir.listFiles()) {
            matches = findMatches(f, from, to);

            if (matches != null) {
                return matches;
            }
        }
    }

    return null;
}

task updateCalamus(dependsOn: [downloadOldVersionDetails, nestOldJar, downloadVersionDetails, nestJar]) {
    group = mappingGenerationGroup
    inputs.files(oldMainJar, mainJar, oldNestedJar, nestedJar)

    outputs.file(calamusFile)
    outputs.upToDateWhen {
        return calamusFile.exists()
    }

    doLast {
        if (calamusFile.exists()) {
            return
        }

        if (!oldCalamusFile.exists()) {
            throw new RuntimeException("Cannot update calamus from ${old_version_id} to ${version_id}: calamus for ${old_version_id} does not exist!")
        }

        File jar = nestedJar.exists() ? nestedJar : mainJar
        File oldJar = oldNestedJar.exists() ? oldNestedJar : oldMainJar
        File matchesFile = findMatches(old_version_id, version_id)
        List<String> args = new ArrayList<>()
        if (environment.isClient()) {
            args.add("--client-hash")
            args.add(versionDetails.downloads.client.sha1)
        }
        if (environment.isServer()) {
            args.add("--server-hash")
            args.add(versionDetails.downloads.server.sha1)
        }

        CalamusUtil.updateCalamus(oldJar, jar, oldCalamusFile, calamusFile, matchesFile, args.toArray())
    }
}

static List<String> getPublishedVersions() {
    def xml = new URL("https://maven.ornithemc.net/releases/net/ornithemc/calamus/maven-metadata.xml").text
    def metadata = new XmlSlurper().parseText(xml)
    def versions = metadata.versioning.versions.version*.text()
    return versions
}

def publishedVersions
try {
    publishedVersions = getPublishedVersions()
} catch (ignored) {
}

def localMappingsPath = "$buildDir/v2Mappings"
new File(localMappingsPath).mkdirs()
file('mappings').eachFile {
    if (!it.name.endsWith(".tiny")) return

    def mcVer = it.name.replace(".tiny", "")

    if (publishedVersions != null && publishedVersions.contains(mcVer)) {
        project.logger.lifecycle("Skipping ${mcVer} as it has already been released")
        return
    }

    File v1MappingFile = it
    File v2MappingFile = new File("$localMappingsPath/${it.name}")
    File nests = file("nests/${mcVer}.nest")

    def conversionTask = "convert${it.name}ToV2"
    tasks.register(conversionTask) {
        group = "V2 Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v2MappingFile)

        doLast {
            new ConvertMappingsCommand().run(
                    "tiny",
                    v1MappingFile.path,
                    "tinyv2:official:calamus",
                    v2MappingFile.path
            )
        }
    }

    Jar makeV1Jar = makeJar(mcVer, v1MappingFile, nests, false)
    Jar makeV2Jar = makeJar(mcVer, v2MappingFile, nests, true)

    build.dependsOn makeV1Jar
    build.dependsOn makeV2Jar

    makeV2Jar.dependsOn conversionTask

    publishing {
        publications {
            create("${mcVer.replace(" ", "")}_mavenJava", MavenPublication) {
                groupId 'net.ornithemc'
                artifactId "calamus"
                version mcVer
                artifact(makeV1Jar.archiveFile) {
                    builtBy makeV1Jar
                }
                artifact(makeV2Jar.archiveFile) {
                    builtBy makeV2Jar
                    classifier = "v2"
                }
            }
        }
    }

}

def makeJar(String mcVersion, File mappings, File nests, boolean v2) {
    def jarFilename = "calamus-" + mcVersion + (v2 ? "-v2" : "")
    return task("${mcVersion}_makeJar" + (v2 ? "v2" : ""), type: Jar) {
        baseName jarFilename
        from(file(mappings)) {
            into "mappings"
            rename mappings.name, "mappings.tiny"
        }
        if (nests.exists()) {
            from(file(nests)) {
                into "mappings"
                rename nests.name, "mappings.nest"
            }
        }
        destinationDirectory = file("build/jars")
    }
}

publishing {
    repositories {
        if (ENV.MAVEN_URL) {
            maven {
                url ENV.MAVEN_URL
                credentials {
                    username ENV.MAVEN_USERNAME
                    password ENV.MAVEN_PASSWORD
                }
                authentication {
                    basic(BasicAuthentication)
                }
            }
        }
    }
}
