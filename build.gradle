import com.google.common.hash.Hashing
import com.google.common.io.Files
import cuchaz.enigma.command.ConvertMappingsCommand
import groovy.json.JsonSlurper
import groovy.xml.XmlSlurper
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.stitch.util.CalamusUtil
import net.ornithemc.nester.Nester
import org.apache.commons.io.FileUtils

import java.nio.charset.Charset
import java.nio.file.Paths

buildscript {
    repositories {
        maven {
            name "Quilt"
            url "https://maven.quiltmc.org/repository/release"
        }
        maven {
            name "Ornithe"
            url "https://maven.ornithemc.net/releases"
        }
    }

    dependencies {
        classpath "net.ornithemc:enigma-cli:1.2.6"
        classpath "net.ornithemc:nester:0.4.0"
        classpath "net.ornithemc:stitch:0.7.11"
        classpath "commons-io:commons-io:2.8.0"
        classpath "org.codehaus.groovy:groovy-json:3.0.9"
        classpath "org.codehaus.groovy:groovy-xml:3.0.9"
    }
}

plugins {
    id 'de.undercouch.download' version '4.1.1'
    id 'java'
    id 'maven-publish'
}

def ENV = System.getenv()

def jarSetupGroup = "jar setup"
def mappingGenerationGroup = "mapping generation"
def cacheFilesMinecraft = file(".gradle/minecraft")
def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")

def minecraft_version = ENV.MC_VERSION
def old_minecraft_version = ENV.OLD_MC_VERSION

// files for the version for which to generate calamus
def versionFile = new File(cacheFilesMinecraft, "${minecraft_version}.json")
def versionDetailsFile = new File(cacheFilesMinecraft, "${minecraft_version}-details.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")
def mergedFile = new File(cacheFilesMinecraft, "${minecraft_version}-merged.jar")
def nestedMergedFile = new File(cacheFilesMinecraft, "${minecraft_version}-merged-nested.jar")
def calamusFile = file("mappings/${minecraft_version}.tiny")

// files for the version from which to update calamus
def oldVersionFile = new File(cacheFilesMinecraft, "${old_minecraft_version}.json")
def oldVersionDetailsFile = new File(cacheFilesMinecraft, "${old_minecraft_version}-details.json")
def oldClientJar = new File(cacheFilesMinecraft, "${old_minecraft_version}-client.jar")
def oldServerJar = new File(cacheFilesMinecraft, "${old_minecraft_version}-server.jar")
def oldMergedFile = new File(cacheFilesMinecraft, "${old_minecraft_version}-merged.jar")
def oldNestedMergedFile = new File(cacheFilesMinecraft, "${old_minecraft_version}-merged-nested.jar")
def oldCalamusFile = file("mappings/${old_minecraft_version}.tiny")

static boolean validateChecksum(File file, String checksum) {
    if (file != null) {
        //noinspection GrDeprecatedAPIUsage
        def hash = Files.asByteSource(file).hash(Hashing.sha1())
        def builder = new StringBuilder()
        hash.asBytes().each {
            builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
        }
        return builder.toString() == checksum
    }
    return false
}

task downloadVersionsManifest {
    group = jarSetupGroup
    //inputs.property "mc_ver", minecraft_version
    inputs.property "currenttime", new Date()

    outputs.file(manifestFile)

    doLast {
        logger.lifecycle(":downloading minecraft versions manifest")
        FileUtils.copyURLToFile(new URL("https://skyrising.github.io/mc-versions/version_manifest.json"), manifestFile)
    }
}

static def getManifestVersion(File manifestFile, String minecraft_version) {
    def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile, Charset.defaultCharset())) : null
    return manifest != null ? manifest.versions.stream().filter({
        (it.id == minecraft_version)
    }).findFirst() : java.util.Optional.empty()
}

task downloadVersionManifest(dependsOn: downloadVersionsManifest) {
    group = jarSetupGroup
    def manifestVersion = getManifestVersion(manifestFile, minecraft_version)
    //have to grab the release time as there's a current timestamp on each element?!
    inputs.property "releaseTime", manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

    outputs.file versionFile

    doLast {
        manifestVersion = getManifestVersion(manifestFile, minecraft_version)
        //nb need to re-read here in case it didn't exist before
        if (manifestVersion.isPresent() || versionFile.exists()) {

            if (manifestVersion.isPresent()) {
                FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
            }
        } else {
            throw new RuntimeException("No version data for Minecraft version ${minecraft_version} (Did you forget to set the MC_VERSION environment variable?)")
        }
    }
}

task downloadOldVersionManifest(dependsOn: downloadVersionsManifest) {
    group = jarSetupGroup
    def manifestVersion = getManifestVersion(manifestFile, old_minecraft_version)
    //have to grab the release time as there's a current timestamp on each element?!
    inputs.property "releaseTime", manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

    outputs.file oldVersionFile

    doLast {
        manifestVersion = getManifestVersion(manifestFile, old_minecraft_version)
        //nb need to re-read here in case it didn't exist before
        if (manifestVersion.isPresent() || oldVersionFile.exists()) {

            if (manifestVersion.isPresent()) {
                FileUtils.copyURLToFile(new URL(manifestVersion.get().url), oldVersionFile)
            }
        } else {
            throw new RuntimeException("No version data for Minecraft version ${old_minecraft_version} (Did you forget to set the OLD_MC_VERSION environment variable?)")
        }
    }
}

task downloadVersionDetails(dependsOn: downloadVersionsManifest) {
    group = jarSetupGroup
    def manifestVersion = getManifestVersion(manifestFile, minecraft_version)
    inputs.property "manifestUrl", manifestVersion.isPresent() ? manifestVersion.get().url : -1

    outputs.file versionDetailsFile

    doLast {
        manifestVersion = getManifestVersion(manifestFile, minecraft_version)

        if (manifestVersion.isPresent() || versionDetailsFile.exists()) {
            if (manifestVersion.isPresent()) {
                FileUtils.copyURLToFile(new URL(manifestVersion.get().details), versionDetailsFile)
            }
        } else {
            throw new RuntimeException("No version details for Minecraft version ${minecraft_version} (Did you forget to set the MC_VERSION environment variable?)")
        }
    }
}

task downloadOldVersionDetails(dependsOn: downloadVersionsManifest) {
    group = jarSetupGroup
    def manifestVersion = getManifestVersion(manifestFile, old_minecraft_version)
    inputs.property "manifestUrl", manifestVersion.isPresent() ? manifestVersion.get().url : -1

    outputs.file oldVersionDetailsFile

    doLast {
        manifestVersion = getManifestVersion(manifestFile, old_minecraft_version)

        if (manifestVersion.isPresent() || oldVersionDetailsFile.exists()) {
            if (manifestVersion.isPresent()) {
                FileUtils.copyURLToFile(new URL(manifestVersion.get().details), oldVersionDetailsFile)
            }
        } else {
            throw new RuntimeException("No version details for Minecraft version ${old_minecraft_version} (Did you forget to set the OLD_MC_VERSION environment variable?)")
        }
    }
}

task downloadMcJars(dependsOn: downloadVersionManifest) {
    group = jarSetupGroup
    inputs.files versionFile

    outputs.files(clientJar, serverJar)
    outputs.upToDateWhen {
        def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, Charset.defaultCharset()))
        return clientJar.exists() && serverJar.exists() && validateChecksum(clientJar, version.downloads.client.sha1) && validateChecksum(serverJar, version.downloads.server.sha1)
    }

    doLast {
        if (!versionFile.exists()) {
            throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
        }

        //reload in case it changed
        def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, Charset.defaultCharset()))

        logger.lifecycle(":downloading minecraft jars for ${minecraft_version}")

        download {
            src new URL(version.downloads.client.url)
            dest clientJar
            overwrite false
        }

        download {
            src new URL(version.downloads.server.url)
            dest serverJar
            overwrite false
        }
    }
}

task downloadOldMcJars(dependsOn: downloadOldVersionManifest) {
    group = jarSetupGroup
    inputs.files oldVersionFile

    outputs.files(oldClientJar, oldServerJar)
    outputs.upToDateWhen {
        def version = new JsonSlurper().parseText(FileUtils.readFileToString(oldVersionFile, Charset.defaultCharset()))
        return oldClientJar.exists() && oldServerJar.exists() && validateChecksum(oldClientJar, version.downloads.client.sha1) && validateChecksum(oldServerJar, version.downloads.server.sha1)
    }

    doLast {
        if (!oldVersionFile.exists()) {
            throw new RuntimeException("Can't download the jars without the ${oldVersionFile.name} file!")
        }

        //reload in case it changed
        def version = new JsonSlurper().parseText(FileUtils.readFileToString(oldVersionFile, Charset.defaultCharset()))

        logger.lifecycle(":downloading minecraft jars for ${old_minecraft_version}")

        download {
            src new URL(version.downloads.client.url)
            dest oldClientJar
            overwrite false
        }

        download {
            src new URL(version.downloads.server.url)
            dest oldServerJar
            overwrite false
        }
    }
}

task mergeJars(dependsOn: downloadMcJars) {
    group = jarSetupGroup
    inputs.files downloadMcJars.outputs.files.files

    outputs.file(mergedFile)

    doLast {
        logger.lifecycle(":merging jars")
        def client = inputs.files.files.find { it.name.endsWith("-client.jar") }
        def server = inputs.files.files.find { it.name.endsWith("-server.jar") }
        def merged = mergedFile

        if (merged.exists()) {
            return
        }

        def jarMerger = new JarMerger(client, server, merged)
        jarMerger.merge()
        jarMerger.close()
    }

}

task mergeOldJars(dependsOn: downloadOldMcJars) {
    group = jarSetupGroup
    inputs.files downloadOldMcJars.outputs.files.files

    outputs.file(oldMergedFile)

    doLast {
        logger.lifecycle(":merging jars")
        def client = inputs.files.files.find { it.name.endsWith("-client.jar") }
        def server = inputs.files.files.find { it.name.endsWith("-server.jar") }
        def merged = oldMergedFile

        if (merged.exists()) {
            return
        }

        def jarMerger = new JarMerger(client, server, merged)
        jarMerger.merge()
        jarMerger.close()
    }

}

task nestJar(dependsOn: mergeJars) {
    group = jarSetupGroup
    inputs.file mergedFile

    outputs.file(nestedMergedFile)

    doLast {
        logger.lifecycle(":nesting jar")
        def merged = mergedFile
        def nested = nestedMergedFile

        if (nested.exists()) {
            return
        }

        def nests = file("nests/${minecraft_version}.nest")

        if (nests.exists()) {
            Nester.fixJar(Paths.get(merged.getAbsolutePath()), Paths.get(nested.getAbsolutePath()), Paths.get(nests.getAbsolutePath()))
        }
    }

}

task nestOldJar(dependsOn: mergeOldJars) {
    group = jarSetupGroup
    inputs.file oldMergedFile

    outputs.file(oldNestedMergedFile)

    doLast {
        logger.lifecycle(":nesting jar")
        def merged = oldMergedFile
        def nested = oldNestedMergedFile

        if (nested.exists()) {
            return
        }

        def nests = file("nests/${old_minecraft_version}.nest")

        if (nests.exists()) {
            Nester.fixJar(Paths.get(merged.getAbsolutePath()), Paths.get(nested.getAbsolutePath()), Paths.get(nests.getAbsolutePath()))
        }
    }

}

// this task will probably not work for certain versions, but we'll cross that bridge when we get there
task generateCalamus(dependsOn: [downloadVersionDetails, nestJar]) {
    group = mappingGenerationGroup
    inputs.file nestedMergedFile

    outputs.file(calamusFile)
    outputs.upToDateWhen {
        return calamusFile.exists()
    }

    doLast {
        if (calamusFile.exists()) {
            return
        }

        CalamusUtil.generateCalamus(nestedMergedFile.exists() ? nestedMergedFile : mergedFile, calamusFile, null)
    }
}

static File findMatches(String from, String to) {
    // first check if we have our own nested matches
    File matches = new File("nested-matches/${from}#${to}.match");

    if (matches.exists()) {
        return matches;
    }

    // TODO: check if nested matches exist the other way around and invert them

    // check skyrising's matches
    // matches are organized in folders for each major release
    for (File dir : new File("matches/matches/merged/").listFiles()) {
        matches = new File(dir, "${from}#${to}.match");

        if (matches.exists()) {
            return matches;
        }
    }

    // no matches found...
    throw new RuntimeException("matches from ${from} to ${to} do not exist!");
}

task updateCalamus(dependsOn: [downloadOldVersionDetails, nestOldJar, downloadVersionDetails, nestJar]) {
    group = mappingGenerationGroup
    inputs.files(oldNestedMergedFile, nestedMergedFile)

    outputs.file(calamusFile)
    outputs.upToDateWhen {
        return calamusFile.exists()
    }

    doLast {
        if (calamusFile.exists()) {
            return
        }

        if (!oldCalamusFile.exists()) {
            throw new RuntimeException("Cannot update calamus from ${old_minecraft_version} to ${minecraft_version}: calamus for ${old_minecraft_version} does not exist!")
        }

        File matchesFile = findMatches(old_minecraft_version, minecraft_version)
        File oldJar = oldNestedMergedFile.exists() ? oldNestedMergedFile : oldMergedFile
        File newJar = nestedMergedFile.exists() ? nestedMergedFile : mergedFile

        CalamusUtil.updateCalamus(oldJar, newJar, oldCalamusFile, calamusFile, matchesFile)
    }
}

static List<String> getPublishedVersions() {
    def xml = new URL("https://maven.ornithemc.net/releases/net/ornithemc/calamus/maven-metadata.xml").text
    def metadata = new XmlSlurper().parseText(xml)
    def versions = metadata.versioning.versions.version*.text()
    return versions
}

def publishedVersions
try {
    publishedVersions = getPublishedVersions()
} catch (ignored) {
}

def localMappingsPath = "$buildDir/v2Mappings"
new File(localMappingsPath).mkdirs()
file('mappings').eachFile {
    if (!it.name.endsWith(".tiny")) return

    def mcVer = it.name.replace(".tiny", "")

    if (publishedVersions != null && publishedVersions.contains(mcVer)) {
        project.logger.lifecycle("Skipping ${mcVer} as it has already been released")
        return
    }

    File v1MappingFile = it
    File v2MappingFile = new File("$localMappingsPath/${it.name}")
    File nestsFile = file("nests/${mcVer}.nest")

    def conversionTask = "convert${it.name}ToV2"
    tasks.register(conversionTask) {
        group = "V2 Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v2MappingFile)

        doLast {
            new ConvertMappingsCommand().run(
                    "tiny",
                    v1MappingFile.path,
                    "tinyv2:official:calamus",
                    v2MappingFile.path
            )
        }
    }

    Jar makeV1Jar = makeJar(mcVer, v1MappingFile, nestsFile, false)
    Jar makeV2Jar = makeJar(mcVer, v2MappingFile, nestsFile, true)

    build.dependsOn makeV1Jar
    build.dependsOn makeV2Jar

    makeV2Jar.dependsOn conversionTask

    publishing {
        publications {
            create("${mcVer.replace(" ", "")}_mavenJava", MavenPublication) {
                groupId 'net.ornithemc'
                artifactId "calamus"
                version mcVer
                artifact(makeV1Jar.archiveFile) {
                    builtBy makeV1Jar
                }
                artifact(makeV2Jar.archiveFile) {
                    builtBy makeV2Jar
                    classifier = "v2"
                }
            }
        }
    }

}

def makeJar(String mcVersion, File mappings, File nests, boolean v2) {
    def jarFilename = "calamus-" + mcVersion + (v2 ? "-v2" : "")
    return task("${mcVersion}_makeJar" + (v2 ? "v2" : ""), type: Jar) {
        baseName jarFilename
        from(file(mappings)) {
            into "mappings"
            rename mappings.name, "mappings.tiny"
        }
        if (nests.exists()) {
            from(file(nests)) {
                into "mappings"
                rename nests.name, "mappings.nest"
            }
        }
        destinationDirectory = file("build/jars")
    }
}

publishing {
    repositories {
        if (ENV.MAVEN_URL) {
            maven {
                url ENV.MAVEN_URL
                credentials {
                    username ENV.MAVEN_USERNAME
                    password ENV.MAVEN_PASSWORD
                }
                authentication {
                    basic(BasicAuthentication)
                }
            }
        }
    }
}
